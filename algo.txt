import random
import socket
# from socket import AF_PACKET, SOCK_RAW
from struct import pack
import re
import constants as constants
from constants import format_and_validate_ip, format_and_validate_mac, get_checksum


class ClientSocket:
    # TODO
    # Tornar os atributos de endereços necessários conforme a implementação avançar
    def __init__(self, source_mac="", dest_mac="", source_ip="", dest_ip="", source_port=0, dest_port=0, protocol=constants.RAW_TYPE, net_interface="eth0",):
        self.socket = socket.socket(
            socket.AF_PACKET, socket.SOCK_RAW, protocol)
        self.protocol = protocol
        self.source_port = source_port
        self.dest_port = dest_port
        self._format_and_validate_addresses(
            source_mac, dest_mac, source_ip, dest_ip)
        self.set_interface(net_interface)

    def _format_and_validate_addresses(self, source_mac, dest_mac, source_ip, dest_ip):
        try:
            self.source_ip = format_and_validate_ip(source_ip)
            self.dest_ip = format_and_validate_ip(dest_ip)
            self.source_mac = format_and_validate_mac(source_mac)
            self.dest_mac = format_and_validate_mac(dest_mac)
        except Exception as err:
            # TODO
            # Formatar execuções com erro
            print("Erro ao formatar endereço: ", err)
            raise Exception

    def set_interface(self, interface):
        self.socket.bind((interface, 0))

    def _create_eth_header(self):
        # 6 dest address, 6 source address and 2 for ethtype = IP
        protocol_type = self.protocol

        # 6 bytes for destination mac
        # 6 bytes for source mac
        # 1 int for protocol type
        pkg = pack("!6s6sH", self.dest_mac,
                   self.source_mac, protocol_type)
        return pkg

    def _create_ip_header(self, data):
        # TODO
        # FRAGMENTAR IP



        # referencia: https://github.com/vinayrp1/TCP-IP-implementation-using-RAW-sockets/blob/master/rawhttpget.py
        # constants for IP header
        DATA_LEN = len(data.encode("utf-8"))
        IHL = 5
        IP_VERSION = 4
        TYPE_OF_SERVICE = 0
        DONT_FRAGMENT = 0
        IP_HDR_LEN = 20
        UDP_LEN = 8 + DATA_LEN
        FRAGMENT_STATUS = DONT_FRAGMENT
        TIME_TO_LIVE = 255

        # TODO Fazer um handler que controla se vai usar tcp ou udp
        PROTOCOL = socket.IPPROTO_UDP
        pkt_id = random.randint(10000, 50000)
        checksum = 0
        total_len = IP_HDR_LEN + UDP_LEN
        IHL_VERSION = IHL + (IP_VERSION << 4)

        ip_header = pack('!BBHHHBBH4s4s', IHL_VERSION, TYPE_OF_SERVICE, total_len,
                         pkt_id, FRAGMENT_STATUS, TIME_TO_LIVE, PROTOCOL, checksum, self.source_ip, self.dest_ip)

        checksum = get_checksum(ip_header)

        ip_header = pack('!BBHHHBBH4s4s', IHL_VERSION, TYPE_OF_SERVICE, total_len,
                         pkt_id, FRAGMENT_STATUS, TIME_TO_LIVE, PROTOCOL, checksum, self.source_ip, self.dest_ip)

        return ip_header

    def _create_udp_header(self, data=None):
        PROTOCOL = socket.IPPROTO_UDP
        SRC_PORT = self.source_port
        DEST_PORT = self.dest_port
        SRC_IP = self.source_ip
        DEST_IP = self.dest_ip
        data = data.encode()
        FINAL_LEN = 8 + len(data)
        checksum = 0

        


        header = SRC_IP + DEST_IP + pack('!BBH', 0, PROTOCOL, FINAL_LEN)
        udp_header = pack('!4H', SRC_PORT, DEST_PORT, FINAL_LEN, checksum)
        checksum = get_checksum(header + udp_header + data)
        udp_header = pack('!4H', SRC_PORT, DEST_PORT, FINAL_LEN, checksum)
        return udp_header

    def send_package(self, data: str):
        # TODO
        # Concatenar outros headers e data conforme avançar a implementação
        eth_header = self._create_eth_header()
        ip_headers = self._create_ip_header(data)
        udp_header = self._create_udp_header(data)
        # headers = eth_header + ip_header + tcp_header
        headers = eth_header + ip_headers + udp_header

        package = headers + data.encode("utf-8")

        self.socket.send(package)





#########

import socket
from struct import pack
import re
IPV4_TYPE = 0x0800
UNKNOWN_TYPE = socket.IPPROTO_IP  # FOR TESTS
RAW_TYPE = socket.SOCK_RAW



def get_checksum(data):
    checksum = 0

    data_len = len(data)
    if (data_len % 2):
        data_len += 1
        data += pack('!B', 0)

    # Divida o cabeçalho em palavras de 16 bits e some-as
    for i in range(0, len(data), 2):
        w = (data[i] << 8) + data[i + 1]
        checksum += w
    # Some o excesso de carry de 16 bits para obter o resultado final
    while (checksum >> 16) > 0:
        checksum = (checksum & 0xFFFF) + (checksum >> 16)
    # Faça o complemento de 1 do resultado
    checksum = ~checksum & 0xFFFF
    print(checksum)
    return checksum


def format_and_validate_ip(ip: str):
    aux_ip = ip.replace(".", "")
    try:
        int(aux_ip)
        if not re.match("[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}", "127.0.0.1"):
            raise Exception

        result = socket.inet_aton(ip)
    except Exception as e:
        raise e
    return result

def format_and_validate_mac(mac: str):
    aux_mac = mac.replace(":", "")
    try:
        if len(aux_mac) != 12:
            raise Exception
        if not re.match("[0-9a-f]{2}([-:]?)[0-9a-f]{2}(\\1[0-9a-f]{2}){4}$", mac.lower()):
            raise Exception

        result = bytes.fromhex(aux_mac)
    except Exception as e:
        raise e
    return result





#######


from models.clientSocket import ClientSocket
from constants import IPV4_TYPE

CONFIG = {
    # "MAC_ORIGEM": "a4:1f:72:f5:90:52",
    "MAC_ORIGEM": "a4:1f:72:f5:90:5c",
    "MAC_DESTINO": "a4:1f:72:f5:90:98",
    "IP_ORIGEM": "192.168.0.1",
    "IP_DESTINO": "192.168.0.1",
    "PORTA_ORIGEM": "61",
    "PORTA_DESTINO": "68",
    "INTERFACE_REDE": "eth0"
}


def main():
    socket = ClientSocket(source_mac=CONFIG["MAC_ORIGEM"],     # Substituir pelos endereços MAC desejados
                       dest_mac=CONFIG["MAC_DESTINO"],
                       source_ip=CONFIG["IP_ORIGEM"],
                       dest_ip=CONFIG["IP_DESTINO"],
                       # Substituir pelo nome da interface de rede da máquina
                       net_interface=CONFIG["INTERFACE_REDE"],
                       protocol=IPV4_TYPE  # Remover caso for usar apenas ethernet
                       )

    socket.send_package(data="mensagem de teste")


if __name__ == "__main__":
    main()
